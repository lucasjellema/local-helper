<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Image EXIF extractor (vanilla JS + Leaflet)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- Leaflet CSS (CDN) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root{
      --bg:#f7fafc; --card:#ffffff; --muted:#6b7280; --accent:#0ea5a4;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    body{margin:0;background:var(--bg);color:#111;}
    .wrap{max-width:900px;margin:28px auto;padding:18px;}
    .card{background:var(--card);padding:16px;border-radius:10px;box-shadow:0 1px 6px rgba(0,0,0,.06);}
    h1{margin:0 0 8px;font-size:20px;}
    p.lead{margin:0 0 12px;color:var(--muted);font-size:14px;}
    .drop{border:2px dashed #d1d5db;padding:18px;border-radius:8px;text-align:center;background:#fff;cursor:pointer;}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
    button, .btn{padding:8px 12px;border-radius:8px;border:1px solid #e5e7eb;background:#fff;cursor:pointer;}
    button.primary{background:var(--accent);color:#fff;border-color:transparent;}
    .status{font-family:monospace;color:#111;background:#f3f4f6;padding:8px;border-radius:6px;}
    .grid{display:grid;grid-template-columns:1fr 300px;gap:12px;margin-top:12px;}
    @media (max-width:820px){ .grid{grid-template-columns:1fr;} }
    .map{height:320px;border-radius:8px;overflow:hidden;border:1px solid #e5e7eb;}
    .meta{font-family:monospace;background:#f9fafb;padding:10px;border-radius:8px;border:1px solid #eef2f7;}
    .notice{font-size:13px;color:var(--muted);margin-top:8px;}
    .error{color:#b91c1c;background:#fff4f4;padding:8px;border-radius:6px;border:1px solid #fecaca;}
    label{display:block;margin-bottom:6px;font-weight:600;}
    .row{display:flex;gap:8px;align-items:center;}
    .hidden{display:none;}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Image EXIF extractor</h1>
      <p class="lead">Upload, drop or paste an image. The app extracts timestamp and geolocation from EXIF (client-side only). Uses Leaflet to show the location.</p>

      <div id="drop" class="drop" tabindex="0" aria-label="Drop area (also click to open file dialog). Press Enter to open.">
        <div>Drag & drop an image here, click to browse, or paste (Ctrl+V).</div>
        <div class="notice">Tip: many smartphone camera photos contain timestamp & GPS. Social platforms sometimes strip EXIF.</div>
      </div>

      <div class="controls" style="margin-top:10px">
        <input id="fileInput" type="file" accept="image/*" class="hidden" />
        <button id="btnBrowse" class="btn">Choose file</button>
        <button id="btnPaste" class="btn">Read clipboard (image)</button>
        <button id="btnClear" class="btn">Reset</button>
        <div style="flex:1"></div>
        <div id="status" class="status">idle</div>
      </div>

      <div id="err" class="error hidden" role="alert" style="margin-top:10px;"></div>

      <div class="grid" style="margin-top:14px;">
        <div>
          <label for="preview">Preview</label>
          <div id="preview" class="card" style="min-height:200px;display:flex;align-items:center;justify-content:center;">
            <img id="imgPreview" alt="" style="max-width:100%;max-height:320px;border-radius:6px;display:none" />
            <div id="noPreview" style="color:var(--muted)">No image yet</div>
          </div>

          <div style="margin-top:12px;">
            <label>Metadata</label>
            <div id="metadata" class="meta">No metadata yet</div>
            <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap;">
              <button id="copyCoords" class="btn" disabled>Copy coords</button>
              <button id="downloadMeta" class="btn" disabled>Download JSON</button>
            </div>
          </div>
        </div>

        <div>
          <label>Location map</label>
          <div id="map" class="map">Map will appear here if GPS found</div>
          <div id="mapNote" class="notice" style="margin-top:8px">Map loads with GPS — Leaflet loaded from CDN.</div>
        </div>
      </div>

      <div class="notice" style="margin-top:12px">
        <strong>Privacy:</strong> Processing is done locally in your browser. Images are not uploaded to any server by this page.
      </div>
    </div>
  </div>

  <!-- Dependencies: EXIF.js + Leaflet (CDNs) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
  (function(){
    // Config
    const MAX_BYTES = 50 * 1024 * 1024; // 50 MB
    // Elements
    const drop = document.getElementById('drop');
    const fileInput = document.getElementById('fileInput');
    const btnBrowse = document.getElementById('btnBrowse');
    const btnPaste = document.getElementById('btnPaste');
    const btnClear = document.getElementById('btnClear');
    const statusEl = document.getElementById('status');
    const errEl = document.getElementById('err');
    const previewImg = document.getElementById('imgPreview');
    const noPreview = document.getElementById('noPreview');
    const metadataEl = document.getElementById('metadata');
    const copyCoordsBtn = document.getElementById('copyCoords');
    const downloadMetaBtn = document.getElementById('downloadMeta');
    const mapEl = document.getElementById('map');
    let lastMeta = null;
    let map = null, marker = null;

    function setStatus(s){ statusEl.textContent = s; }
    function showError(msg){
      errEl.textContent = msg;
      errEl.classList.remove('hidden');
    }
    function clearError(){
      errEl.classList.add('hidden');
      errEl.textContent = '';
    }

    // Utility: convert EXIF DMS array to decimal
    function dmsToDecimal(dms, ref){
      if (!dms) return null;
      // elements may be numbers or objects (numerator/denominator) or strings
      function toNum(v){
        if (typeof v === 'number') return v;
        if (!v) return NaN;
        if (typeof v === 'string' && v.indexOf('/')>-1){
          const parts = v.split('/');
          return Number(parts[0]) / Number(parts[1]);
        }
        if (typeof v === 'object' && 'numerator' in v && 'denominator' in v){
          return v.numerator / v.denominator;
        }
        return Number(v);
      }
      const deg = toNum(dms[0]) || 0;
      const min = toNum(dms[1]) || 0;
      const sec = toNum(dms[2]) || 0;
      let dec = deg + (min / 60) + (sec / 3600);
      if (ref === 'S' || ref === 'W') dec = -dec;
      return dec;
    }

    function formatTimestamp(raw){
      if (!raw) return null;
      // EXIF often stores "YYYY:MM:DD HH:MM:SS"
      // Keep original but also show a nicer version if possible
      const s = String(raw).trim();
      const normalized = s.replace(/^(\d{4}):(\d{2}):(\d{2})/, '$1-$2-$3');
      // try Date parsing (may be local)
      const d = new Date(normalized);
      if (!isNaN(d)) return d.toString() + " (from EXIF: " + s + ")";
      return s;
    }

    // Image reading & EXIF extraction
    async function processFile(file){
      clearError();
      setStatus('reading file');
      lastMeta = null;
      copyCoordsBtn.disabled = true;
      downloadMetaBtn.disabled = true;
      if (!file) return;
      if (file.size > MAX_BYTES) {
        showError('File too large. Please use images under 50 MB.');
        setStatus('idle');
        return;
      }
      // preview
      const objectURL = URL.createObjectURL(file);
      previewImg.src = objectURL;
      previewImg.style.display = 'block';
      noPreview.style.display = 'none';

      // read arrayBuffer
      setStatus('parsing EXIF');
      try {
        const buf = await file.arrayBuffer();
        // exif-js provides EXIF.readFromBinaryFile
        const tags = EXIF.readFromBinaryFile(buf) || {};
        // try a few date tags
        const dateTags = ['DateTimeOriginal', 'DateTime', 'DateTimeDigitized'];
        let timestamp = null;
        for (const t of dateTags){
          if (tags[t]) { timestamp = tags[t]; break; }
        }
        // GPS
        const latTag = tags.GPSLatitude;
        const lonTag = tags.GPSLongitude;
        const latRef = tags.GPSLatitudeRef;
        const lonRef = tags.GPSLongitudeRef;
        let lat = null, lon = null;
        if (latTag && lonTag){
          lat = dmsToDecimal(latTag, latRef);
          lon = dmsToDecimal(lonTag, lonRef);
        } else {
          // some cameras/apps put coordinates in other tags or description; do a scan for plausible numeric lat/lon pairs
          for (const k of Object.keys(tags)){
            const v = tags[k];
            if (!v) continue;
            if (Array.isArray(v) && v.length === 2 && typeof v[0] === 'number' && typeof v[1] === 'number'){
              if (lat === null) lat = v[0];
              if (lon === null) lon = v[1];
            }
          }
        }

        const meta = {
          filename: file.name || 'pasted-image',
          size: file.size,
          type: file.type,
          timestampRaw: timestamp || null,
          timestampParsed: formatTimestamp(timestamp) || null,
          gpsRaw: (lat && lon) ? { lat: lat, lon: lon } : null,
          rawTags: tags
        };

        lastMeta = meta;
        renderMeta(meta);
        setStatus('done');
        downloadMetaBtn.disabled = false;
        if (meta.gpsRaw){
          copyCoordsBtn.disabled = false;
          showMap(meta.gpsRaw.lat, meta.gpsRaw.lon);
        } else {
          copyCoordsBtn.disabled = true;
          clearMap();
        }

      } catch (e){
        console.error(e);
        showError('Error parsing EXIF: ' + (e.message || e));
        setStatus('error');
        clearMap();
      }
    }

    function renderMeta(meta){
      if (!meta){
        metadataEl.textContent = 'No metadata yet';
        return;
      }
      const lines = [];
      lines.push('File: ' + meta.filename + ' (' + Math.round(meta.size/1024) + ' KB)');
      lines.push('MIME: ' + (meta.type || 'unknown'));
      lines.push('Timestamp: ' + (meta.timestampParsed || '— not found in EXIF'));
      if (meta.gpsRaw){
        lines.push('Geolocation: ' + meta.gpsRaw.lat.toFixed(6) + ', ' + meta.gpsRaw.lon.toFixed(6));
      } else {
        lines.push('Geolocation: — not found in EXIF');
      }
      // show raw tag summary (small)
      lines.push('');
      lines.push('--- raw EXIF tags (selected) ---');
      const selective = {};
      ['Make','Model','DateTime','DateTimeOriginal','GPSLatitude','GPSLongitude','GPSLatitudeRef','GPSLongitudeRef'].forEach(k=>{
        if (meta.rawTags[k] !== undefined) selective[k] = meta.rawTags[k];
      });
      metadataEl.textContent = lines.join('\\n') + '\\n\\n' + JSON.stringify(selective, null, 2);
    }

    // Map utilities
    function showMap(lat, lon){
      if (!lat || !lon) return;
      // initialize map if not yet
      if (!map){
        map = L.map('map', { attributionControl: true }).setView([lat, lon], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: '© OpenStreetMap'
        }).addTo(map);
      } else {
        map.setView([lat, lon], 13);
      }
      if (marker) marker.remove();
      marker = L.marker([lat, lon]).addTo(map);
      marker.bindPopup('Location: ' + lat.toFixed(6) + ', ' + lon.toFixed(6)).openPopup();
    }

    function clearMap(){
      if (marker){ marker.remove(); marker = null; }
      if (map){
        try { map.remove(); } catch(e) {}
        map = null;
      }
      mapEl.innerHTML = 'Map will appear here if GPS found';
    }

    // Copy coords
    copyCoordsBtn.addEventListener('click', async () => {
      if (!lastMeta || !lastMeta.gpsRaw) return;
      const txt = lastMeta.gpsRaw.lat + ', ' + lastMeta.gpsRaw.lon;
      try {
        await navigator.clipboard.writeText(txt);
        alert('Coordinates copied: ' + txt);
      } catch(e){
        showError('Failed to copy to clipboard: ' + (e.message||e));
      }
    });

    // Download metadata
    downloadMetaBtn.addEventListener('click', () => {
      if (!lastMeta) return;
      const blob = new Blob([JSON.stringify(lastMeta, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = (lastMeta.filename||'image') + '.metadata.json';
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 500);
    });

    // File input & browsing
    btnBrowse.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (f) processFile(f);
      fileInput.value = '';
    });

    // Drag & drop
    drop.addEventListener('dragover', (e)=>{ e.preventDefault(); drop.style.borderColor = '#9ca3af'; });
    drop.addEventListener('dragleave', (e)=>{ drop.style.borderColor = '#d1d5db'; });
    drop.addEventListener('drop', (e)=> {
      e.preventDefault();
      drop.style.borderColor = '#d1d5db';
      clearError();
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if (f) processFile(f);
    });
    // Click to open
    drop.addEventListener('click', ()=> fileInput.click());
    drop.addEventListener('keydown', (e)=> { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); fileInput.click(); } });

    // Paste (Ctrl+V)
    window.addEventListener('paste', (e)=>{
      if (!e.clipboardData) return;
      const items = e.clipboardData.items;
      if (!items) return;
      for (const item of items){
        if (item.kind === 'file' && item.type.startsWith('image/')){
          const blob = item.getAsFile();
          processFile(blob);
          e.preventDefault();
          return;
        }
      }
    });

    // Read clipboard via Async Clipboard API (button fallback)
    btnPaste.addEventListener('click', async () => {
      clearError();
      if (!navigator.clipboard || !navigator.clipboard.read) {
        showError('Async clipboard API not available or permission denied. Use Ctrl+V to paste instead.');
        return;
      }
      try {
        const items = await navigator.clipboard.read();
        for (const it of items){
          for (const type of it.types){
            if (type.startsWith('image/')){
              const blob = await it.getType(type);
              processFile(blob);
              return;
            }
          }
        }
        showError('No image found in clipboard.');
      } catch(e){
        showError('Clipboard read failed: ' + (e.message||e));
      }
    });

    // Reset
    btnClear.addEventListener('click', ()=>{
      previewImg.style.display = 'none';
      previewImg.src = '';
      noPreview.style.display = 'block';
      metadataEl.textContent = 'No metadata yet';
      clearMap();
      lastMeta = null;
      clearError();
      setStatus('idle');
      copyCoordsBtn.disabled = true;
      downloadMetaBtn.disabled = true;
    });

    // Initialization
    setStatus('idle');
    metadataEl.textContent = 'No metadata yet';
    // ensure map container starts empty
    mapEl.innerHTML = 'Map will appear here if GPS found';

  })();
  </script>
</body>
</html>
